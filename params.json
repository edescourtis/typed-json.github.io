{"name":"Typed JSON","tagline":"Format for defining structured JSON data","body":"# Typed JSON\r\n\r\nTyped JSON is a format for defining structured [JSON][]\r\ndata, that can be used by type systems or contract / guard librarires\r\nto allow cross-language type-safety guarantees.\r\n\r\nTyped JSON enables type information to be preserved between typed\r\nand untyped languages. It can be used by developer tools and compilers\r\nto decrease the burden of validating and using data.\r\n\r\nTyped JSON supports:\r\n\r\n* Primitive types: int, float, etc.\r\n* Basic data structures: collections, records, and tuples\r\n* Constants: values such as `4` and `true`\r\n* Union types: which can express Algebraic Data Types and sub-types\r\n\r\nEvery type is associated with a unique URI. This can be used simply as\r\na unique identifier, or it can be associated with a type definition.\r\n\r\n\r\n## Primitive Types\r\n\r\nTyped JSON defines base primitive types that are common to almost all\r\nlanguages. Each primitive type is associated with specific URIs.\r\n\r\n```json\r\n{\r\n  \"bool\"  : \"http://typed-json.org/#boolean\",\r\n  \"int\"   : \"http://typed-json.org/#int\",\r\n  \"float\" : \"http://typed-json.org/#float\",\r\n  \"string\": \"http://typed-json.org/#string\",\r\n  \"null\"  : \"http://typed-json.org/#null\"\r\n}\r\n```\r\n\r\nPrimitive types can be referenced by their URI or aliased as a local type.\r\nIn the example above, we created a local type alias for all of our primitive\r\ntypes. These aliases can be used later to make more complex types easier to read.\r\n\r\nThe `null` primitive type represents the absense of value. It is actually\r\na type of its own, not a possible value for all objects.\r\n\r\nSince `null` is valid JSON primitive it can be used instead of URI\r\nhttp://typed-json.org/#null. For example type `empty` can be defined\r\nas an alias to http://typed-json.org/#null as follows: `{ \"empty\": null }`\r\n\r\n\r\n## Composite types\r\n\r\nTyped JSON is great for defining composite types. The key composite types are:\r\n\r\n * Records: a group of named fields, each associated with a type (similar to objects)\r\n * Collections: arrays or lists of a single type\r\n * Tuples: fixed sized containers with mixed types\r\n\r\n### Records\r\n\r\nRecord types represent JSON objects with a specific structure. They are\r\ndefined in terms of field type signatures:\r\n\r\n```json\r\n{\r\n  \"point\": {\r\n    \"x\": \"http://typed-json.org/#int\",\r\n    \"y\": \"http://typed-json.org/#int\"\r\n  }\r\n}\r\n```\r\n\r\nAbove JSON defines `point` type that **must** have `x` and `y` fields\r\nof `int` type. This example uses full URIs to for field type definitions,\r\nbut that's redundant and could be expressed in more eloquent manner:\r\n\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\",\r\n  \"point\": { \"x\": \"int\", \"y\": \"int\" }\r\n}\r\n```\r\n\r\nComposite data type definitions can refer to other composite types:\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\",\r\n  \"point\": { \"x\": \"int\", \"y\": \"int\" },\r\n  \"line\": {\r\n    \"start\": \"point\",\r\n    \"end\": \"point\"\r\n  }\r\n}\r\n```\r\n\r\n### Collections\r\n\r\nCollections, like arrays (or lists, depending on the language),\r\nmust contain items of specified type and are defined\r\nas follows:\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\",\r\n  \"point\": { \"x\": \"int\", \"y\": \"int\" },\r\n  \"shape\": [\"point\"]\r\n}\r\n```\r\n\r\n*Note: The example above defines a `shape` type that is a\r\ncollection of an arbitrary number of `point` items*\r\n\r\nThe following JSON data would conform to the `shape` type:\r\n\r\n```js\r\n[]\r\n[{\"x\":0, \"y\":0}]\r\n[{\"x\":0, \"y\":0}, {\"x\": 0, \"y\": 10}]\r\n[{\"x\":0, \"y\":0}, {\"x\": 0, \"y\": 10}, {\"x\": 10: \"y\": 10}]\r\n```\r\n\r\nIt is also possible to define fixed-size collections:\r\n\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\",\r\n  \"point\": [\"int\", 2],\r\n  \"line\": [\"point\", 2]\r\n}\r\n```\r\n\r\nThe following JSON data would conform to the `line` type:\r\n\r\n```js\r\n[[0,0], [0,10]]\r\n[[0,0], [10,10]]\r\n```\r\n\r\n### Tuples\r\n\r\nTuples are fixed size containers with *mixed* types.\r\nIn contrast to regular fixed size arrays, they define element\r\ntypes by index.\r\n\r\n```json\r\n{\r\n  \"int\": \"http://typed-json.org/#int\",\r\n  \"string\": \"http://typed-json.org/#string\",\r\n  \"color\": \"string\",\r\n  \"point\": { \"x\": \"int\", \"y\": \"int\" },\r\n  \"pixel\": {\r\n    \"0\": \"point\",\r\n    \"1\": \"color\"\r\n  }\r\n}\r\n```\r\n\r\nThe above `pixel` type defines a structure for values like:\r\n\r\n```js\r\n[{x:0, y:0}, \"red\"]\r\n[{x:0, y:12}, \"green\"]\r\n```\r\n\r\n*Note: \"color\" is just an alias for a string with a different\r\nsemantic meaning. It's useful to give semantic meaning to entities\r\nused in type definitions, as it allows changing the types of those entities\r\nindependently from computed types. This makes it easy to replace color with\r\na record of RGB values at some point.*\r\n\r\n## Metadata\r\n\r\nNew primitives can be defined by aliasing existing primitive types\r\nand adding some additional metadata. For example type `digit` can\r\nbe defined as:\r\n\r\n```json\r\n{\r\n  \"digit\": \"http://typed-json.org/#int\",\r\n  \"digit:meta\": {\r\n    \"min\": 0,\r\n    \"max\": 9\r\n  }\r\n}\r\n```\r\n\r\nNote that above definition uses \"digit:meta\" key to define metadata\r\nfor the `digit` type. Metadata keys must be mapped to objects whose\r\nfields are not specified by this format. Different environments may\r\nchoose to support metadata fields. For example, the `digit` type's metadata\r\nspecifies range of ints, but if runtime does not support ranges, it\r\nwill still treat `digit` as `int` type.\r\n\r\n## Constants\r\n\r\nSpecification recognizes constants of `string`, `integer`, `float`\r\nand `boolean` types:\r\n\r\n```json\r\n{\r\n  \"readyStatus\": 1,\r\n  \"readyState\": \"'complete'\",\r\n  \"yes\": true,\r\n}\r\n```\r\n\r\nAbove data structure defines type `readyStatus` constant of `int`\r\ntype that will only match `1`. Type `yes` is a boolean that is\r\n`true`. Type `readyState` is a constant primitive that matches\r\n`'complete'` string in JSON although in some languages that could\r\ntranslate to more appropriate contant values like [keywords][]\r\nin clojure.\r\n\r\nIn languages like Elm and Haskell, the name of the constant type\r\ncould be used to create a simple Algebraic Data Type:\r\n\r\n```haskell\r\ndata ReadyStatus = ReadyStatus\r\ndata ReadyState = ReadyState\r\ndata Yes = Yes\r\n```\r\n\r\n## Union types\r\n\r\nComposite types can also be defined in form of [union types][] to\r\nallow structures that can contain non-homogeneous types:\r\n\r\n```json\r\n{\r\n  \"string\": \"http://typed-json.org/#string\",\r\n  \"pending\": true,\r\n  \"complete\": { \"data\": \"string\" },\r\n  \"status\": \"pending|complete\"\r\n}\r\n```\r\n\r\nThis is very natural in untyped languages like JavaScript, but it\r\nalso maps nicely onto [Algebraic Data Types][] (ADTs) in functional\r\nlanguages like Elm and Haskell. It also maps onto subclasses in OO\r\nlanguages like Java.\r\n\r\nIn Haskell, the `\"status\"` type would be represented as:\r\n\r\n```haskell\r\ndata Status = Pending | Complete { data :: String }\r\n```\r\n\r\n## Unions with Constant Types\r\n\r\nAs we saw above, unions can be defined over constant types:\r\n\r\n```json\r\n{\r\n  \"yes\": \"'yes'\",\r\n  \"no\": \"'no'\",\r\n  \"show\": \"yes|no\"\r\n}\r\n```\r\n\r\nIn JavaScript, the values passed along would be a string `'yes'` or\r\n`'no'`. A statically-typed functional language like Elm or Haskell\r\nwould represent this as:\r\n\r\n```haskell\r\ndata Show = Yes | No\r\n```\r\n\r\nIt is guaranteed that members of a union type are named, so it is\r\nalways safe to map onto an ADT or class heirarchy.\r\n\r\nThere is also syntax sugar to express above in more concise way:\r\n\r\n```json\r\n{\r\n  \"show\": \"'yes'|'no'\"\r\n}\r\n```\r\n\r\nIt is still possible to map this onto ADTs because strings implicitly have names.\r\nUnlike strings, constant integers and floats must be defined explicitly to ensure\r\nthey have a name.\r\n\r\n```json\r\n{\r\n  \"two\": 2,\r\n  \"three\": 3,\r\n  \"five\": 5,\r\n  \"seven\": 7,\r\n  \"prime-digits\": \"two|three|five|seven\"\r\n}\r\n```\r\n\r\nIn JavaScript, this would just send an integer over the wire.\r\nIn Haskell or Elm, this would be represented as:\r\n\r\n```haskell\r\ndata PrimeDigits = Two | Three | Five | Seven\r\n```\r\n\r\nThis lets you work with the colloquial representation in very different languages.\r\n\r\n# Prior art:\r\n\r\n- [Elm records](http://elm-lang.org/learn/Records.elm)\r\n- [MongoDB BSON](http://bsonspec.org/)\r\n- [JSON Schema](http://json-schema.org/)\r\n- [Protocol buffers](https://developers.google.com/protocol-buffers/docs/overview)\r\n\r\n[JSON]:http://json.org/\r\n[structural typing]:http://en.wikipedia.org/wiki/Structural_type_system\r\n[keywords]:http://clojure.org/data_structures#Data%20Structures-Keywords\r\n[Union_types]:https://en.wikipedia.org/wiki/Union_type\r\n[algebraic_data_types]:http://elm-lang.org/learn/Pattern-Matching.elm\r\n","google":"UA-42944832-1","note":"Don't delete this file! It's used internally to help with page regeneration."}